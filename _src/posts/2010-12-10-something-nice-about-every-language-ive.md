    Title: Something nice about every language I've used
    Date:2010-12-10T19:00:00
    Tags: pablolife

Inspired by [this post][1] (and more great answers on the [reddit comment
thread][2]), here's one nice thing about each of the languages I can
remember using in any meaningful capacity:

**Java:** I learned to program in this. It led to the creation of the JVM, and
while Java isn't my favorite language, the JVM is a pretty sexy piece of
technology that enabled a number of other languages (Scala and Clojure most
notable) to flourish.


**C:** The closest thing imperative programming has to "sparse beauty," a la
Scheme. Shows you really don't need many bells and whistles to do a job, and
do it well.


**C++:** Back when everyone was using C, it's kind of a technical miracle that
Bjarne could create a proper superset on top of C with the features it has.
Further, it's still blazing fast; without it we wouldn't have all the video
games we love today ^_^.


**PHP:** Incredibly easy to learn, and no-hassle to set up on a server. One of
the matches that lit the web on fire.


**Racket (and Scheme applies here too):** The language that never lets up. The
most delicious learning curve I've ever tasted. Like Wagner's music is
jokingly said to be "better than it sounds," Racket is more fun and fulfilling
than it deserves to be.


**Erlang:** Industry-proven functional programming with more concurrency love
than 1000 suns. Also the top language for gaining hipster-programmer cred.
When you drop this name, suddenly everyone looks at you like "that guy" (you
can decide if this is what you want or not).


**Haskell:** A wolf in sheeps's clothing, the most modern, practical, and
supported language with features I think we'll see as necessary in the future.
Another candidate for learning curve that keeps on giving.\*

**SML:** A really sick module system for programming in the large. While not
my favorite for "programming in the small," an understanding of SML's module
system makes you pity that it never really took off.


**Ruby:** One of the most beautifully designed, fully-realized languages I
know. Shows you can make a language that is simple, with practical value for
[Herp Derp][3] programmers without sacrificing power and flexibility for the
craftsmen as well.


**Objective-C:** The _real_ "C with objects." Message passing with named
parameters (and the much more sensible #import rather than #include), this is
one time where I'm highly in favor of Mr. Jobs' stubbornness.


**Prolog:** [10-second youtube video.][4] I mean this in a good way.


**Max/MSP:** Probably the most fully-realized and pleasing graphical
programming environment I know, as well as an example of a damn fine DSL.


**Javascript:** I don't have to worry about compiler errors! No seriously,
[prototypical objects][5] for the masses.


**Flapjax:** Functional reactive programming! An excellent example of
functional languages and concepts attacking problems from the language level.
Very innovative workaround for the horrors of client-side programming of the
time.


**Actionscript:** Adobe makes it! Like Java, but better (Flash Platform >
Swing/most Java GUI's).


\*= Small qualification on the learning curve lines: virtually any language
takes years of work over dozens of programs to "master." But many times
mastering a language means compensating for its weaknesses, not discovering
new strengths. That's what Haskell and Racket have given me more than most
other languages.


   [1]: http://blog.darevay.com/2010/12/say-something-nice-about-every-language-youve-used/

   [2]: http://www.reddit.com/r/programming/comments/eirzj/say_something_nice_about_every_language_youve_used/

   [3]: http://knowyourmeme.com/memes/derp

   [4]: http://www.youtube.com/watch?v=HY-03vYYAjA

   [5]: http://en.wikipedia.org/wiki/Prototype-based_programming

